# Динамическое программирование


Динамическое программирование — это когда у нас есть задача, которую непонятно как решать, и мы разбиваем ее на меньшие задачи, которые тоже непонятно как решать. Очень крутая техника решения задач.

Дп применяется для нахождения оптимального решения, или для подсчёта способов решения.

Для того чтобы решить задачу с помощью ДП, надо разобраться с :
1. какие состояния
2. начальные значения, некоторых состояний
3. пересчёт новых состояний из ранее посчитанных состояний, не обязательно по порядку
4. состояния где ответ

Более подробнее :

1. Состояния обычно одномерные или двумерные. Например, сколько первых элементов массива мы рассматриваем, или начало и конец рассматриваемого отрезка. Могут быть и более многомерные случае.

2. Начальные состояния это максимально простые состояния, для которых ответ уже известен. Например, наибольшая длина НВП, которая начинается в текущей позиции равна 1.

3. Новые состояния пересчитываются из учёта значений уже посчитанных состояний. Если придумать правильные состояния и пересчёт их то можно считать что задача уже решена. 

4. Состояния в которых хранится ответ легко определить из структуры состояний. Скорее всего, ответ это значение в самом последнем слое &mdash; `dp[n]` или `max(dp[n][i])` для всех `i` от `1` до `n`.

# Числа Фибоначчи

Рассмотрим задачу, посчитать $n$-ое значение ряда [Фибоначчи](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%B0_%D0%A4%D0%B8%D0%B1%D0%BE%D0%BD%D0%B0%D1%87%D1%87%D0%B8).

$0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, \dots$

## Решение рекурсией

Можно написать рекурсивную функцию для вычисления $n$-го числа, которая работает за $O(2^n)$:

```cpp
int fib(int n)
{
    if (n <= 1)
        return n;
    return fib(n - 1) + fib(n - 2);
}
```

## Решение динамическим программированием

По пунктам :

1. Состояния $i$ &mdash; $i$-ое число Фибоначчи.
2. Начальное значение будет только у первых двух членов последовательности $f_0 = 0, f_1 = 1$
3. Пересчёт $i$-го состояния следует из определения &mdash; $f_i = f_{i - 1} + f_{i - 2}$
4. Ответ на задачу будет $n$-ое состояние.

## Нерекурсивный способ

Иногда значения можно пересчитать по порядку. Например, как в этой задаче.

```cpp
int fib[n + 1];

fib[0] = 0;
fib[1] = 0;
for (int i = 2; i <= n; i++) {
	fib[i] = fib[i - 1] + fib[i - 2];
}
cout << fib[n];
```

## Рекурсивный способ

Такой способ ещё называется ленивой динамикой (или мемонизацией). Иногда сложно или вообще невозможно придумать  порядок пересчёта динамики, что все необходимые значения уже посчитаны.


 ```cpp
std::vector<int> f(MAX_N, -1);

int fib(int n)
{
  if (f[n] != -1) { // +
    return f[n]; // +
  } // +

  if (n <= 1)
    return n;
  return  fib(n - 1) + fib(n - 2);
}
```

Условие `f[n] != -1` проверяет на то, что значение уже было посчитано. Получается асимптотика $O(n)$

# Комбинаторные задачи

Почти все (хотя пока я писал, я нашёл обратное, видимо, все не комбинаторные задачи запомнились больше) задачи сформулированы так : посчитайте количество ... по простому модулю.

Так как значения ДП, равны или сумме значений или вообще умножаются на что-то, следовательно значения не вмещаются в нормальные целочисленные типы.

Поэтому надо написать пару функций, для поддерживания значений по модулю. 

```cpp
const int MOD = 1e9 + 7;

inline int add(const int &a, const int &b) { // a + b
    return (a + b >= MOD) ? a + b - MOD : a + b;
}

inline int sub(const int &a, const int &b) { // a - b
    return (a - b < 0) ? a - b + MOD : a - b;
}

inline int mult(const int &a, const int &b) { // a * b
    return (1LL * a * b) % MOD;
}
```

# Восстановление ответа

Очень редко просят восстановить ответ.

Для этого храним дополнительно массив, в котором храним состояние откуда через которое мы обновили текущее состояние, при пересчёте.

Пример, (на самом деле таких задач много, мне просто лень) : 

[Цветная полоска](../tasks/colored-stripe.md)

[Найди Число](../tasks/find-number.md)

# Виды динимики

По подотрезкам
По цифрам
По подмноджествам 
По поддеревьям 

```admonish warning
Умение придумывать динамику очень важно. Иногда, задачи настолько просто решаются **только** этой техникой.
Тема реально очень многогранна, существуют разные приёмы, некоторые базовые постановки задачи (например, задача с некоторой модификацей, будет эквивалентна задачи о рюкзаке или подобной базовой задачи). 


!Это достаточно сложно. Приёмы оптимизации, такие как, [много трюков](https://codeforces.com/blog/entry/47764), минимизация состояний, разделя и властвуй, сохранения оптимума для быстрого пересчёта ([Кнута](https://ru.algorithmica.org/cs/layer-optimizations/knuth/)), специальные структуры данных для быстрого пересчёта ([дерево Ли Чао](https://peltorator.ru/posts/li-chao/), [cht](https://ru.algorithmica.org/cs/layer-optimizations/convex-hull-trick/)), дискретный метод Лагранжа, [SOS](https://codeforces.com/blog/entry/45223). +-300 оптимизация

Это, как и многие темы, можно понять если только решить очень много задачи.

Мне очень впадлу находить вам задачи, особенно так чтобы они реально были полезны, чтобы вы с самого нуля прокачались, (я знаю некоторые крутые задачи, на мой взгляд, но я их решал достаточно недавно, и они были полезны для меня, а не для вас).

^^^ Я подумаю над этим большим топиком примерно летом.
```

Тупо покидаю ссылки :

1. [Динамика по подотрезкам](https://ru.algorithmica.org/cs/general-dynamic/segments/) 
2. [Ленивая динамика](https://ru.algorithmica.org/cs/general-dynamic/memoization/)
3. [Динамика по цифрам](https://wiki.algocode.ru/index.php?title=%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BF%D0%BE_%D1%86%D0%B8%D1%84%D1%80%D0%B0%D0%BC)
4. (en) [Введение в ДП](https://usaco.guide/gold/intro-dp?lang=cpp)
5. (en) [Всё о рюкзаке, и задачи похожие](https://usaco.guide/gold/knapsack?lang=cpp)
6. (en) Аналогично [Пути на сетке](https://usaco.guide/gold/paths-grids?lang=cpp)
7. (en) Аналогично [НВП](https://usaco.guide/gold/lis?lang=cpp)
8. (en) Аналогично [Подмаски](https://usaco.guide/gold/dp-bitmasks?lang=cpp)
9. (en) Аналогично [подотрезки](https://usaco.guide/gold/dp-ranges?lang=cpp)
10. (en) Аналогично [По цифрам](https://usaco.guide/gold/digit-dp?lang=cpp)
11. (en) Аналогично [По поддеревьям](https://usaco.guide/gold/dp-trees) + ещё там есть рерутинг


в 4-11 реально крутой сайт, задачи данные внизу очень крутые. 

Задачи :

1. [просто посмотрите самые простые задачи на динамику на кф'е](https://codeforces.com/problemset?order=BY_SOLVED_DESC&tags=dp) (там разбор есть) я не знаю как сказать, но там как раз половина задач самых простых не динамика, или это немного сложнее чем решение другое
2. [специальный контект на динамику (есть самые базовые)](https://atcoder.jp/contests/dp/tasks) (есть сотни разборов)
3. [секция Dynamic Programming 20+задач (есть самые базовые)](https://cses.fi/problemset/list/)
4. [какие-то задачи](https://codeforces.com/blog/entry/67679)

Давайте рассмотрю пару :
  - [Между Двумя Массивами](../tasks/between-two-arrays.md)
  - [Общие Подпоследовательности](../tasks/common-subsequence.md)
  - [Цветные Кирпичики](../tasks/bricks.md)
  - [Переупорядочивание](../tasks/reordering.md)
  - [Отсортирована?](../tasks/is-sorted.md)
  - [Цветная Полоска](../tasks/colored-stripe.md)
  - [Красное И Синее Дерево](../tasks/red-blue-tree.md)
  - [Хорошая Бинарная Матрица](../tasks/nice-binary-matrix.md)
  - [Квадратные Подмножества](../tasks/square-subsets.md)
  - [Совместимые Числа](../tasks/compatible-numbers.md)