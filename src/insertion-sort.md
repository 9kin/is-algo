# Сортировка вставкой

> Сортировка вставкой чем-то похожа игру в карты, мы добавляем элемент к чему-то уже отсортированному.
> Имеющийся массив надо условно разбить на отсортированную часть и неотсортированную, а потом добавлять по одному элементу к отсортированной части, **вставляя** его в нужное место

Сложность: ***O(n^2)***

## Преимущества алгоритма
1. Легкий для понимания и воспроизведения алгоритм
2. Эффективен для маленьких массивов

## Недостатки алгоритма
1. Сложность в среднем и худшем случаях - O(n^2)
2. Медленно работает на больших массивах

## Реализация алгоритма

```cpp
#include <iostream>

void insertionSort( int *arr, int size ) {
    int key;

    for (int i = 1; i < size; i++) {
        int j = i - 1;

        key = arr[i];
 
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }

        arr[j + 1] = key;
    }
}

int main( void ) {
    int size, *array;

    std::cin >> size;

    array = new int[size];
    
    for (int i = 0; i < size; i++) {
        std::cin >> array[i];
    }

    insertionSort(array, size);

    for (int i = 0; i < size; i++) {
        std::cout << array[i] << " ";
    }
}
```

## Ввод

```bash
6
4 1 2 5 4 -68
```

## Работа алгоритма
1. Берем 4 как элемент уже отсортированного массива: { 4 }
2. Добавляем к нему 1: 1 < 4, значит, ставим его до 4: { 1 4 }
3. Аналогично добавляем 2: { 1 2 4 }
4. Добавляем 5: 5 > 1, 5 > 2, 5 > 4, значит, ставим его после 4: { 1 2 4 5 }
5. Добавляем 4: 4 > 1, 4 > 2, 4 > 4 == false, значит, ставим его после 2 и до 4: { 1 2 4 4 5 }
6. Аналогично для -68

## Вывод

```bash
-68 1 2 4 4 5
```
