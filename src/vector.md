# std::vector

Динамический массив настоящего альфы)))

Синтаксис `vector<T> variable(n);`. Стоит подключить библиотеку `<vector>`.

Под `капотом` находится `буфер`, который является динамическим массивом. 
Это позволяет быстро выполнять операции, которые изменяют размер вектора, так как `буфер` может быть зарезервирован на большее количество элементов, чем фактически требуется. Размер буфера имеет размер меньшей степени двойки. Например, если делать `n` `push_back` произойдёт `log n` реалокаций памяти.

> Используйте и не думайте.

Есть удобные [методы](https://en.cppreference.com/w/cpp/container/vector): 

`push_back` &mdash; добавляет элемент в конец. Амортизировано за `o(1)`.

`pop_back` &mdash; удаляет элемент в конец. Амортизировано за `o(1)`.

`insert` &mdash; вставляет элемент в произвольное место. За `O(n)`.

`erase` &mdash; удаляет произвольный элемент. За `O(n)`.

`begin, end` &mdash; указатели на начало и конец. Например, нужно для сортировки `sort(a.begin(), a.end());`

Пример решения задачи из блока ["начало работы"](./examples.md) :

```cpp
#include <iostream>

using namespace std;

void solve() {
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }
    sort(a.begin(), a.end());
    for (int i = 0; i + 1 < n; i++) {
        if (a[i + 1] - a[i] > 1) {
            cout << "NO\n";
            return ;
        }
    }
    cout << "YES\n";
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
```

vector vs динамический массив
===

Используйте `vector`, потому-что : 

1. не стоит задумывать о освобождение памяти
2. работает сравнение и копирование (так как переменная не указатель)
3. удобен во всех случаях, когда массив надо быстро изменить

