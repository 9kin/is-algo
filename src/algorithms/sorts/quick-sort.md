# "Быстрая" сортировка

> Quick sort - рекурсивный алгоритм, основанный на принципе "Divide and Conquer" ("Разделяй и властвуй"). Выбирается какая-то опорная точка (pivot point), относительно которой массив разбивается на подмассивы, после чего эта точка ставится на нужное место в массив.

Сложность: ***O(n log(n)) - лучший/средний, O(n^2) - худший***

## Преимущества алгоритма
1. Алгоритм "Разделяй и властвуй" позволяющий легче решать задачу
2. Эффективен для массивов больших размеров
3. Занимает не много памяти

## Недостатки
1. Худшая сложность по времени - O(n^2)
2. Не лучший выбор для массивов небольших размеров
3. Нестабильная сортировка

## Реализация алгоритма.

Опорная точка - середина.

```cpp
void quickSort(int* a, int size) {
  int b = 0, e = size - 1;  // b - begin, e - end

  if (size < 2) return;

  int m = a[size / 2];

  while (b <= e) {
    // Проверка на то, что элементы слева - меньше, а элементы справа - больше
    while (a[b] < m) {
      b++;
    }
    while (a[e] > m) {
      e--;
    }

    // Если слева встретилось число большее, чем опорная точка, а справа -
    // меньшее, меняем их местами
    if (b <= e) {
      if (b != e) {
        std::swap(a[b], a[e]);
      }
      b++;
      e--;
    }
  }

  // Рекурсивный вызов сортировки для левой и правой частей
  quickSort(a, e + 1);
  quickSort(a + b, size - b);
}
```

> Запуск функции сортировки `quickSort(array, size - 1);`

## Ввод
```bash
5
9 74 -354 87 0
```

## Работа алгоритма
1. Выбрали -354 как опорную точку, посчитали, ее индекс в итоговом массиве равен 0 - { -354 . . . . }
2. Поменяли местами 9 и -354 -- исходный массив: { -354 74 9 87 0 }
3. Разбили массив на два подмассива { } и { 74 9 87 0 } -- исходный массив: { -354 74 9 87 0 }
4. Меняем местами элементы, не удовлетворяющие условию (слева меньше, справа больше), всё подходит по условию, исходный массив не изменился -- исходный массив: { -354 74 9 87 0 }
5. В каждом из подмассивов выбрали опорную точку как первый элемент (ничего и 74 соответственно) 
6. Первый подмассив состоит из 0 элементов, так что его не рассматриваем
7. Сортируем второй подмассив:
    1. Разбиваем его еще на два подмассива относительно центра: { 74 } и { 87 0 }
    2. Проверяем, выполняется ли условие: не выполняется, 74 > 9, 0 < 9. Исправляем: { 0 } { 87 74 } -- исходный массив: { -354 0 9 87 74}
    3. { 0 } нет смысла разбивать на подмассивы, а вот { 87 74 } разбиваем, получаем еще два подмассива: { } и { 74 }, работаем с ними:
        1. Условие не выполняется, значит, 74 перекидываем влево: { 74 } и { } -- исходный массив: { -354 0 9 74 87}
        2. Дальше разбивать нельзя
8. Массив отсортирован: УРАА ПОБЕДА


## Вывод
```bash
-354 0 9 74 87
```

На практике
===

В качестве опорного элемента следует выбирать случайный элемент массива, чтобы получить гарантированное время сортировки \\( \Theta (n\log n)\\) в среднем.

