# Вещественный поиск

> Пусть $f : \{l, l + 1, \dots, r - 1, r\} \rightarrow \{0, 1\} $ (функция, которая которая на области $[l, r]$ имеет область значений $\{0, 1\}$ и $f$ монотонная на этой области.

Всё что обсуждалось в предыдущей главе про целочисленный поиск работает и тут, так как область значений является аналогом отсортированного массива. Такой поиск называется `вещественный`, так как функция $f(x)$ похожа на математическую функцию. Главное, чтобы функция была монотонной.

Идея та же, что и при целочисленном бинарном поиске : сначала возьмём такие границы поиска $l = L, r = R$. После этого на каждом шаге будем сдвигать одну из границ $l, r$, в зависимости от значения $f\left(\dfrac{l+r}{2}\right)$. В тот момент, когда $l$ и $r$ отличаются на единицу, $r$ &mdash; искомый порог. Если считать, что значение функции в точке вычисляется за $O(1)$, то время работы алгоритма &mdash; $O(\log_2 (R − L))$, где $L, R$ &mdash; начальные границы поиска.

Разовьём идею дальше, можно искать не только целочисленные точки, но и дробные!!! Увы, всерхточности добиться невозможно. Проблема заключается в том, что действительные числа хранятся в компьютере неточно(. Например, если ответ это число $\pi$. Для границ стоит использовать тип с самой большой точностью, в `c++` это тип `double`.

Тем не менее, мы можем найти такое $x$ с погрешностью $\epsilon$:
найдём такое $x$, что существует $x'$ такое, что $f(x') = 0, |x − x'| < \epsilon$. Единственное отличие от обычного бинпоиска : мы завершаем алгоритм в тот момент, когда $r − l < \epsilon$.

Время работы алгоритма (при условии, что значение $f$ вычисляется за $O(1)$ &mdash; $O\left( \log_2 \left( \dfrac{R−L}{\epsilon} \right)\right)$.


Любой алгоритм целочисленного поиска, является подмножеством вещественного, в котором функция бинарна. Например, для проверки есть ли число в массиве, надо было лишь заменить `if (a[mid] < x)` на $f(mid, x) = a[mid] < x$.

