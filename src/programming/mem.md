# Память

> new int[100] создаст в куче массив `int`'ов размера 100, и вернёт указатель на самый первый (нулевой) элемент.
Чтобы не было утечки памяти стоит после того, как мы закончили работать с указателем, удалить его память &mdash; сделать delete pointer. Сугубо говоря, delete вызывает free с нужными параметрами, а ОС освобождает память и отдаёт её в свободный пул памяти

Очистка памяти
===

<!---
 https://ru.stackoverflow.com/questions/659123/%D0%9A%D0%B0%D0%BA-%D0%BE%D1%87%D0%B8%D1%81%D1%82%D0%B8%D1%82%D1%8C-%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C-%D0%B2%D1%8B%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%83%D1%8E-%D0%B4%D0%BB%D1%8F-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%BE%D0%B9
-->

Если вы создаёте переменную, например, string s; - при выходе из области видимости будет вызван деструктор, который освободит связанные с переменной ресурсы. Фундаментальных типы, например, int или double не имеют деструкторов, но они сами удаляются.

cpp
{
  Foo f;
  // используем f
  // ...
  // здесь неявно компилятор сам вставит удаление для f
}


Но, у указателям надо явно удалить ресурсы, это связано из-за строения ссылок c++.

Проще говоря, все типы данных, которые T, а не T* и выделены с new, запустят деструкторов, а у T* мы должны сами запустить. 

Для массивов &mdash; delete[] arr;, а для всего остального delete ptr;

> Если не чистить память, то память может закончится. И ваше решение получит ML или в случае если это приложение, последствия могут быть катастрофические.

Немного про память
===

Stack (стек) выделяется память, а иногда удаляется. Так как локальные переменны, также строчки кода, куда вернуться и тп только создаются, и только последовательно как в стеке удаляются, когда их цикл жизни заканчивается. Другими словами все локальные переменные создаются последовательно в памяти, и также будут просто удалены сдвинув указатель на начало стека.

Heap (Куча) &mdash; это общее название места, куда вы помещаете данные, которые создаёте на лету. Если вы не знаете, сколько космических кораблей будет создавать ваша программа, вы, вероятно, будете использовать оператор new (или malloc или эквивалентный) для создания каждого космического корабля. Это распределение останется на некоторое время, поэтому, вероятно, мы будем освобождать вещи в другом порядке, чем мы их создавали.

Таким образом, куча намного сложнее, потому что в конечном итоге есть неиспользуемые области памяти, чередующиеся с фрагментами памяти, которые фрагментируются. Найти свободную память нужного вам размера &mdash; сложная задача. Вот почему следует избегать кучи.

Следует освобождать память, чтобы не получить утечку памяти.