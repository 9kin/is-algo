# Сумма факториалов

> Вам дано число `n`, ваша задача посчитать сумму факториалов : `1! + 2! + 3! + ... + n!`. Ограничение на `n` до \\(10^6\\). Ответ выведите по простому модулю `10^9 + 7`.

Разбор условия
===

> Ответ по `модулю` часто встречается в условие для того чтобы участники могли оперировать в диапазоне целочисленных типов языка программирования. Но в большинстве случаев модулем является `1000000007` &mdash; \\(10^9 + 7\\). 

На самом деле, модуль используется для того, чтобы облегчить, а не усложнить вычисления. Это может показаться нелогичным, но как только вы узнаете, как работает модульная арифметика, вы поймёте, почему.

<!--
https://blog.mitrichev.ch/2014/06/this-week-in-competitive-programming_11.html

https://codeforces.com/blog/entry/72527?locale=ru
-->

>  `простой` модуль, так как это связано с модульной арифметикой (я сам особо не могу ответить на этот вопрос) (скоро перепишу это)

Решение в лоб
=== 

Факториал числа \\(n \\) можно посчитать за \\(O(n)\\) простым циклом.

В коде ниже используется модуль, как видите это не страшно

> `1LL` это переменная `long long` равная `1`, `LL` [суффиксный литерал](https://en.cppreference.com/w/cpp/language/integer_literal) типа. Если умножить два `int`'а между собой, то может произойти переполнение, поэтому надо считать в `long long`. При умножение `long long` на `int` получается `long long`.

> По уму люди делают функции `add(a, b)` и `mult(a, b)` которые уже внутри складывают и умножают по модулю соответственно.

> Очевидно, что число типа `long long` взятое по модулю `1e9 + 7` имеет диапазон \\([0, 10^9 + 7)\\) и влазит в `int`.

```cpp
int mod = 1e9 + 7;
int factorial(int n) {
  int res = 1;
  for (int i = 1; i <= n; i++) {
    res = (1LL * res * i) % mod;
  }
  return res;
}
```

Тогда чтобы решить задачу, можно \\(n\\) раз запустить функцию `factorial` :

```cpp
int sum = 0;
for (int i = 1; i <= n; i++) {
	sum = (sum + factorial(i)) % mod;
}
cout << sum;
```

Хочу вас расстроить, асимптотика этого решения \\(O(n^2)\\).

Подумайте, как особо ничего не переписывая сделать асимптотику \\(O(n)\\).

Быстрое решение 
=== 

Достаточно вспомнить определение факториала :

\\[n! = 1 \cdot 2 \cdot 3 \cdot \dots \cdot n \\]

Из определение следует, что

\\[n! = (n-1)! \cdot n\\]

Значит, для подсчёта следующего факториала, достаточно знать факториал предыдущего числа.

Код полного решения занимает пару строк. Рекомендую разобраться подробно в нём :

```cpp
void solve() {
  int n, mod = 1e9 + 7, fac = 1, sum = 0;
  cin >> n;
  for (int i = 1; i <= n; i++) {
    fac = (1LL * fac * i) % mod;
    sum = (sum + fac) % mod;
  }
  cout << sum;
}
```

Асимптотика решения \\(O(n)\\).
