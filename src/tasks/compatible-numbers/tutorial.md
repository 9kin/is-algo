Что такое $a_i \ \& \ x = 0$? Значит для всех `j`-ых бит выполняется эти условия по определению $\&$:

* $a_{i_j} = 1$, значит $x_j = 0$
* $a_{i_j} = 0$, значит $x_j = 0$ или $x_j = 1$

Пусть $x$ произвольное число. `~x` инвертированное по битам `x`. Перепишем условия выше:

* $a_{i_j} = 1$, значит $\sim x_j = 1$
* $a_{i_j} = 0$, значит $\sim x_j = 0$ или $\sim x_j = 1$

Другими словами:

* $\sim x_j = 1$, значит $a_{i_j}$ любое
* $\sim x_j = 0$, значит $a_{i_j} = 0$

$\forall j \text{ если } \sim x_j = 0, a_{i_j}=0$

Пример:

$x_{(2)} = 0101 = 5$

$\sim x_{(2)} = \red{0}1\red{0}$

$a_{(2)} = 0000000000\red{0}0\red{0} = 0; 0 \ \& \ 5 = 0$

$a_{(2)} = 0000000000\red{0}1\red{0} = 2; 2 \ \& \ 5 = 0$

$a_{(2)} = 0000000001\red{0}0\red{0} = 8; 8 \ \& \ 5 = 0$

$a_{(2)} = 0000000001\red{0}1\red{0} = 10; 10 \ \& \ 5 = 0$

$a_{(2)} = 0000000010\red{0}0\red{0} = 16; 16 \ \& \ 5 = 0$
...

---

Посчитаем динамику по маскам $can[mask]$.

$mask = \sim x$

$mask$ - зафиксируем позиции $\red{0}$. Для условия $\forall j \text{ если } mask_j = 0, z_{j}=0$. Следовательно на позициях $mask_j = 1$ можно поставить $0/1$. 

$can[mask]$ - значение $z$ или $-1$, можно ли собрать $mask=z'$, где $z'$ новая $z$ если некоторые $0$ в $z_{(2)}$ поменять на $1$.

$can[mask | (1 \text{ << } j)] = \forall j \ can[mask]$

Ответ для значения $a_i$, находится в $can[mask]$, где $mask = 111111_{(2)} - a_i$.

```cpp

const int M = 22;
int can[(1 << M) + 1];

void solve() {
  fill(begin(can), end(can), -1);
  int n;
  cin >> n;
  vector<int> a(n);
  for (int i = 0; i < n; i++) {
    cin >> a[i];
    can[a[i]] = a[i];
  }
  for (int j = 0; j < M; pos++) {
    for (int mask = 0; mask < (1 << M); mask++) {
      if (can[mask] != -1) {
        can[mask | (1 << j)] = can[mask];
      }
    }
  }
  int ones = (1 << M) - 1;
  for (int i = 0; i < n; i++) {
    cout << (can[ones - a[i]] != -1 ? can[ones - a[i]] : -1) << ' ';
  }
}
```

TODO чё за z? я видимо мискуликнул